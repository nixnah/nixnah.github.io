<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.91.2"><meta name=theme-color content="#16171d"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>92.Docker容器技术详解 | Hanxin</title><link rel=stylesheet href=/css/meme.min.88c90dc75021618344ec926f4ed6ac307f30ba48911294816b16370a41e5f137.css><script src=/js/meme.min.f460a174bb100a60a7e275913695161f1e09aab1378fe99cfd30cde14da70888.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Satisfy&family=Klee+One:wght@400;600&family=Great+Vibes&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Satisfy&family=Klee+One:wght@400;600&family=Great+Vibes&display=swap"></noscript><meta name=author content="骆昊"><meta name=description content="Docker容器技术详解 Docker是基于Go语言开发的开源应用容器引擎，遵从Apa……"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Hanxin"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Hanxin"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=/python/92.docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2021-08-23T17:33:56+08:00","dateModified":"2022-01-16T09:24:35+00:00","url":"/python/92.docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/","name":"92.Docker容器技术详解","description":"Docker容器技术详解 Docker是基于Go语言开发的开源应用容器引擎，遵从Apa……","image":"/icons/apple-touch-icon.png","license":"本文采用[「CC BY-NC-SA 4.0」](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)协议，转载请注明出处。","publisher":{"@type":"Organization","name":"Hanxin","logo":{"@type":"ImageObject","url":"/icons/apple-touch-icon.png"},"url":"/"},"mainEntityOfPage":{"@type":"WebSite","@id":"/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="92.Docker容器技术详解"><meta property="og:description" content="Docker容器技术详解 Docker是基于Go语言开发的开源应用容器引擎，遵从Apa……"><meta property="og:url" content="/python/92.docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="Hanxin"><meta property="og:locale" content="zh"><meta property="og:image" content="/icons/apple-touch-icon.png"><meta property="og:type" content="website"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Hanxin</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/life/><span class=menu-item-name>生活</span></a></li><li class=menu-item><a href=/tech/><span class=menu-item-name>技术</span></a></li><li class=menu-item><a href=/tags/><span class=menu-item-name>标签</span></a></li><li class=menu-item><a href=/about/><span class=menu-item-name>关于</span></a></li><li class=menu-item><a href=/blogroll/><span class=menu-item-name>友链</span></a></li><li class=menu-item><a href=/python/><span class=menu-item-name>Python-100天</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=python data-toc-num=true><h1 class="post-title p-name">92.Docker容器技术详解</h1><div class=post-meta><time datetime=2021-08-23T17:33:56+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2021.8.23</time>
<time datetime=2022-01-16T09:24:35+00:00 class="post-meta-item modified dt-updated"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M4e2 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H48C21.49 64 0 85.49.0 112v352c0 26.51 21.49 48 48 48h352c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 4e2H54a6 6 0 01-6-6V160h352v298a6 6 0 01-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;2022.1.16</time>
<span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;9273</span>
<span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;19&nbsp;分钟</span></div><div class="post-body e-content"><h2 id=docker容器技术详解><a href=#docker容器技术详解 class=anchor-link>#</a>Docker容器技术详解</h2><p>Docker是基于Go语言开发的开源应用容器引擎，遵从Apache Licence 2.0协议，可以让开发者打包应用以及应用的依赖包到一个可移植的容器中，然后发布到各种发行版本的Linux系统上。</p><h3 id=docker简介><a href=#docker简介 class=anchor-link>#</a>Docker简介</h3><p>软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台下都可以正常的运转，而且在不同的环境下我们安装的软件需要依赖的软件包也是不一样的。</p><p>那么问题来了，我们安装软件的时候可不可以把软件运行的环境一并安装？我们是不是可以把原始环境一模一样地复制过来呢？</p><p>虚拟机（virtual machine）就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统，在macOS上运行Windows，而应用程序对此毫无感知。使用过虚拟机的人都知道，虚拟机用起来跟真实系统一模一样，而对于虚拟机的宿主系统来说，虚拟机就是一个普通文件，不需要了就删掉，对宿主系统或者其他的程序并没有影响。但是虚拟机通常会占用较多的系统资源，启动和关闭也非常的缓慢，总之用户体验并没有想象中的那么好。</p><p>Docker属于对Linux容器技术（LXC）的一种封装（利用了Linux的namespace和cgroup技术），它提供了简单易用的容器使用接口，是目前最流行的 Linux 容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。下图是虚拟机和容器的对比，左边是传统的虚拟机，右边是Docker。</p><p><img src=/res/docker_vs_vm.png alt></p><p>目前，Docker主要用于几下几个方面：</p><ol><li>提供一次性的环境。</li><li>提供弹性的云服务（利用Docker很容易实现扩容和收缩）。</li><li>实践微服务架构（隔离真实环境在容器中运行多个服务）。</li></ol><h3 id=安装docker><a href=#安装docker class=anchor-link>#</a>安装Docker</h3><p>下面以CentOS为例讲解如何安装Docker，使用<a href=https://docs.docker.com/install/linux/docker-ce/ubuntu/ target=_blank rel=noopener>Ubuntu</a>、<a href=https://docs.docker.com/docker-for-mac/install/ target=_blank rel=noopener>macOS</a>或<a href=https://docs.docker.com/docker-for-windows/install/ target=_blank rel=noopener>Windows</a>的用户可以通过点击对应的链接了解这些平台下如何进行安装。</p><ol><li><p>确定操作系统内核版本（CentOS 7要求64位，内核版本3.10+；CentOS 6要求64位，内核版本2.6+）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash>uname -r
</code></pre></td></tr></table></div></div></div></li><li><p>更新系统底层的库文件（建议一定要执行，否则在使用Docker时可能会出现莫名其妙的问题）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash>yum update
</code></pre></td></tr></table></div></div></div></li><li><p>移除可能存在的旧的Docker版本。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash>yum list installed <span class=p>|</span> grep docker
yum erase -y docker docker-common docker-engine
</code></pre></td></tr></table></div></div></div></li><li><p>安装yum工具包和依赖项。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash>yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre></td></tr></table></div></div></div></li><li><p>通过yum工具包添加yum源（安装Docker-ce的源）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></td></tr></table></div></div></div></li><li><p>在CentOS下使用yum安装Docker-ce并启动。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash>yum -y install docker-ce
systemctl start docker
</code></pre></td></tr></table></div></div></div></li><li><p>查看Docker的信息和版本。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker version
docker info
</code></pre></td></tr></table></div></div></div></li></ol><p>接下来可以通过下载镜像和创建容器来看看Docker是否可以运转起来。可以使用下面的命令从Docker的镜像仓库下载名为hello-world的镜像文件。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker pull hello-world
</code></pre></td></tr></table></div></div></div><p>查看所有镜像文件。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker images
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>REPOSITORY               TAG        IMAGE ID            CREATED             SIZE
docker.io/hello-world    latest     fce289e99eb9        7 months ago        1.84 kB
</code></pre><p>通过镜像文件创建并运行容器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container run --name mycontainer hello-world
</code></pre></td></tr></table></div></div></div><blockquote><p>说明：其中<code>mycontainer</code>是我们给容器起的名字，跟在<code>--name</code>参数之后；<code>hello-world</code>就是我们刚才下载的镜像文件。</p></blockquote><pre tabindex=0><code>Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre><p>如果要删除这个容器，可以使用下面的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container rm mycontainer
</code></pre></td></tr></table></div></div></div><p>在删除容器之后，我们还可以删除刚才下载的镜像文件。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker rmi hello-world
</code></pre></td></tr></table></div></div></div><blockquote><p>说明：如果要在Ubuntu（内核版本3.10+）下面安装和启动Docker，可以按照如下的步骤进行。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>apt update
apt install docker-ce
service docker start
</code></pre></td></tr></table></div></div></div><p>国内用户可以通过更换Ubuntu软件下载源来提升下载速度，具体请参照清华大学开源软件镜像站上的<a href=https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ target=_blank rel=noopener>《Ubuntu镜像使用帮助》</a>。</p></blockquote><p>安装Docker后，由于直接访问<a href=https://hub.docker.com/ target=_blank rel=noopener>dockerhub</a>下载镜像会非常缓慢，建议将服务器更换为国内镜像，可以通过修改 <code>/etc/docker/daemon.json</code> 文件来做到。一般的云服务器会有自己专属的镜像，就不需要手动修改了。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=p>{</span>
	<span class=s2>&#34;registry-mirrors&#34;</span><span class=o>:</span> <span class=p>[</span>
        <span class=s2>&#34;http://hub-mirror.c.163.com&#34;</span><span class=p>,</span>
        <span class=s2>&#34;https://registry.docker-cn.com&#34;</span>
    <span class=p>]</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></div><h3 id=使用docker><a href=#使用docker class=anchor-link>#</a>使用Docker</h3><p>想要玩转Docker，最简单的办法就是马上用Docker创建一些自己学习和工作中需要用到的容器，下面我们带着大家一起来创建这些容器。</p><h4 id=运行nginx><a href=#运行nginx class=anchor-link>#</a>运行Nginx</h4><p>Nginx是高性能的Web服务器，同时也是做反向代理服务器的上佳选择。使用Docker可以非常简单的创建一个运行Nginx的容器，命令如下所示。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container run -d -p 80:80 --rm --name mynginx nginx
</code></pre></td></tr></table></div></div></div><blockquote><p>说明：上面的参数<code>-d</code>表示容器在后台运行（不产生输出到Shell）并显示容器的ID；<code>-p</code>是用来映射容器的端口到宿主机的端口，冒号前面是宿主机的端口，冒号后面是容器内部使用的端口；<code>--rm</code>表示容器停止后自动删除容器，例如执行命令<code>docker container stop mynginx</code>后，容器就不复存在了；<code>--name</code>后面的mynginx是自定义的容器名字；在创建容器的过程中，需要用到nginx的镜像文件，镜像文件的下载是自动完成的，如果没有指定版本号，默认是最新版本（latest）。</p></blockquote><p>如果需要将自己的Web项目（页面）部署到Nginx上，可以使用容器拷贝命令将指定路径下所有的文件和文件夹拷贝到容器的指定目录中。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container cp /root/web/index.html mynginx:/usr/share/nginx/html
</code></pre></td></tr></table></div></div></div><p>如果不愿意拷贝文件也可以在创建容器时通过数据卷操作<code>--volume</code>将指定的文件夹映射到容器的某个目录中，例如将Web项目的文件夹直接映射到<code>/usr/share/nginx/html</code>目录。我们先通过下面的命令让刚才创建的容器停止运行。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container stop mynginx
</code></pre></td></tr></table></div></div></div><p>然后用下面的命令重新创建容器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container run -d -p 80:80 --rm --name mynginx --volume /root/docker/nginx/html:/usr/share/nginx/html nginx
</code></pre></td></tr></table></div></div></div><blockquote><p>说明：上面创建容器和拷贝文件的命令中，<code>container</code>是可以省略的，也就是说<code>docker container run</code>和<code>docker run</code>是一样的，而<code>docker container cp</code>和<code>docker cp</code>是一样的。此外，命令中的<code>--volume</code>也可以缩写为<code>-v</code>，就如同<code>-d</code>是<code>--detach</code>的缩写，<code>-p</code>是<code>--publish</code>的缩写。<code>$PWD</code>代表宿主系统当前文件夹，这些对于使用过Unix或者Linux系统的人来说，应该是很容易理解的。</p></blockquote><p>要查看运行中的容器，可以使用下面的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker ps
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>CONTAINER ID    IMAGE    COMMAND                  CREATED            STATUS             PORTS                 NAMES
3c38d2476384    nginx    &quot;nginx -g 'daemon ...&quot;   4 seconds ago      Up 4 seconds       0.0.0.0:80-&gt;80/tcp    mynginx
</code></pre><p>要启动和停止容器，可以使用下面的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker start mynginx
docker stop mynginx
</code></pre></td></tr></table></div></div></div><p>由于在创建容器时使用了<code>--rm</code>选项，容器在停止时会被移除，当我们使用下面的命令查看所有容器时，应该已经看不到刚才的<code>mynginx</code>容器了。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container ls -a
</code></pre></td></tr></table></div></div></div><p>如果在创建容器时没有指定<code>--rm</code>选项，那么也可以使用下面的命令来删除容器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker rm mynginx
</code></pre></td></tr></table></div></div></div><p>要删除正在运行中的容器，需要使用<code>-f</code>选项。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker rm -f mynginx
</code></pre></td></tr></table></div></div></div><h4 id=运行mysql><a href=#运行mysql class=anchor-link>#</a>运行MySQL</h4><p>我们再来尝试用Docker安装一台MySQL服务器，首先可以先检查一下有没有MySQL的镜像文件。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker search mysql
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>INDEX        NAME            DESCRIPTION        STARS        OFFICIAL        AUTOMATED
docker.io    docker.io/mysql MySQL is a ...     8486         [OK]
...
</code></pre><blockquote><p>说明：上面查询结果的列依次代表索引、镜像名、镜像描述、用户评价、是否官方镜像、自动构建。</p></blockquote><p>下载MySQL镜像并指定镜像的版本号。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker pull mysql:5.7
</code></pre></td></tr></table></div></div></div><p>如果需要查看已经下载的镜像文件，可以使用下面的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker images
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/nginx     latest              e445ab08b2be        2 weeks ago         126 MB
docker.io/mysql     5.7                 f6509bac4980        3 weeks ago         373 MB
</code></pre><p>创建并运行MySQL容器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run -d -p 3306:3306 --name mysql57 -v /root/docker/mysql/conf:/etc/mysql/mysql.conf.d -v /root/docker/mysql/data:/var/lib/mysql -e <span class=nv>MYSQL_ROOT_PASSWORD</span><span class=o>=</span><span class=m>123456</span> mysql:5.7
</code></pre></td></tr></table></div></div></div><blockquote><p><strong>注意</strong>：上面创建容器时我们又一次使用了数据卷操作，那是因为通常容器是随时创建随时删除的，而数据库中的数据却是需要保留下来的。</p></blockquote><p>上面的两个数据卷操作一个是映射了MySQL配置文件所在的文件夹，一个是映射了MySQL数据所在的文件夹，这两个数据卷操作非常重要。我们可以将MySQL的配置文件放在<code>$PWD/mysql/conf</code>目录下，配置文件的具体内容如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-INI data-lang=INI><span class=k>[mysqld]</span>
<span class=na>pid-file</span><span class=o>=</span><span class=s>/var/run/mysqld/mysqld.pid</span>
<span class=na>socket</span><span class=o>=</span><span class=s>/var/run/mysqld/mysqld.sock</span>
<span class=na>datadir</span><span class=o>=</span><span class=s>/var/lib/mysql</span>
<span class=na>log-error</span><span class=o>=</span><span class=s>/var/log/mysql/error.log</span>
<span class=na>server-id</span><span class=o>=</span><span class=s>1</span>
<span class=na>log-bin</span><span class=o>=</span><span class=s>/var/log/mysql/mysql-bin.log</span>
<span class=na>expire_logs_days</span><span class=o>=</span><span class=s>30</span>
<span class=na>max_binlog_size</span><span class=o>=</span><span class=s>256M</span>
<span class=na>symbolic-links</span><span class=o>=</span><span class=s>0</span>
</code></pre></td></tr></table></div></div></div><p>如果安装了MySQL 8.x版本（目前的最新版本），在使用客户端工具连接服务器时可能会遇到<code>error 2059: Authentication plugin 'caching_sha2_password' cannot be loaded</code>的问题，这是因为MySQL 8.x默认使用了名为“caching_sha2_password”的机制对用户口令进行了更好的保护，但是如果客户端工具不支持新的认证方式，连接就会失败。解决这个问题有两种方式：一是升级客户端工具来支持MySQL 8.x的认证方式；二是进入容器，修改MySQL的用户口令认证方式。下面是具体的步骤，我们先用<code>docker exec</code>命令进入容器的交互式环境，假设运行MySQL 8.x的容器名字叫<code>mysql8x</code>。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker <span class=nb>exec</span> -it mysql8x /bin/bash
</code></pre></td></tr></table></div></div></div><p>进入容器的交互式Shell之后，可以首先利用MySQL的客户端工具连接MySQL服务器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>mysql -u root -p
Enter password:
Your MySQL connection id is <span class=m>16</span>
Server version: 8.0.12 MySQL Community Server - GPL
Copyright <span class=o>(</span>c<span class=o>)</span> 2000, 2018, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type <span class=s1>&#39;help;&#39;</span> or <span class=s1>&#39;\h&#39;</span> <span class=k>for</span> help. Type <span class=s1>&#39;\c&#39;</span> to clear the current input statement.
mysql&gt;
</code></pre></td></tr></table></div></div></div><p>接下来通过SQL来修改用户口令就可以了。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=k>alter</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=s1>&#39;root&#39;</span><span class=o>@</span><span class=s1>&#39;%&#39;</span><span class=w> </span><span class=n>identified</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>mysql_native_password</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=s1>&#39;123456&#39;</span><span class=w> </span><span class=n>password</span><span class=w> </span><span class=n>expire</span><span class=w> </span><span class=n>never</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>当然，如果愿意你也可以查看一下用户表检查是否修改成功。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=n>use</span><span class=w> </span><span class=n>mysql</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>user</span><span class=p>,</span><span class=w> </span><span class=k>host</span><span class=p>,</span><span class=w> </span><span class=n>plugin</span><span class=p>,</span><span class=w> </span><span class=n>authentication_string</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=k>user</span><span class=o>=</span><span class=s1>&#39;root&#39;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=o>+</span><span class=c1>------+-----------+-----------------------+-------------------------------------------+
</span><span class=c1></span><span class=o>|</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>host</span><span class=w>      </span><span class=o>|</span><span class=w> </span><span class=n>plugin</span><span class=w>                </span><span class=o>|</span><span class=w> </span><span class=n>authentication_string</span><span class=w>                     </span><span class=o>|</span><span class=w>
</span><span class=w></span><span class=o>+</span><span class=c1>------+-----------+-----------------------+-------------------------------------------+
</span><span class=c1></span><span class=o>|</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=o>%</span><span class=w>         </span><span class=o>|</span><span class=w> </span><span class=n>mysql_native_password</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=mi>6</span><span class=n>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</span><span class=w> </span><span class=o>|</span><span class=w>
</span><span class=w></span><span class=o>|</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>localhost</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>mysql_native_password</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=mi>6</span><span class=n>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</span><span class=w> </span><span class=o>|</span><span class=w>
</span><span class=w></span><span class=o>+</span><span class=c1>------+-----------+-----------------------+-------------------------------------------+
</span><span class=c1></span><span class=mi>2</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>.</span><span class=mi>00</span><span class=w> </span><span class=n>sec</span><span class=p>)</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>在完成上面的步骤后，现在即便不更新客户端工具也可以连接MySQL 8.x了。</p><h4 id=运行redis><a href=#运行redis class=anchor-link>#</a>运行Redis</h4><p>接下来我们试一试运行多个容器并让多个容器之间通过网络通信。我们创建4个Redis容器来实现一主三从的主从复制结构。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run -d -p 6379:6379 --name redis-master redis
docker run -d -p 6380:6379 --name redis-slave-1 --link redis-master:redis-master redis redis-server --replicaof redis-master <span class=m>6379</span>
docker run -d -p 6381:6379 --name redis-slave-2 --link redis-master:redis-master redis redis-server --replicaof redis-master <span class=m>6379</span>
docker run -d -p 6382:6379 --name redis-slave-3 --link redis-master:redis-master redis redis-server --replicaof redis-master <span class=m>6379</span>
</code></pre></td></tr></table></div></div></div><p>上面的命令中，<code>--link</code>参数用于给容器创建网络别名，因为三台从机（slave）需要通过网络连接自己的主机（master）。虽然，我们可以通过<code>docker inspect --format '{{ .NetworkSettings.IPAddress }}' &lt;container-ID></code>命令来查看到容器的IP地址，但是由于容器的即装即用性，容器的IP地址有可能会发生变化，如果直接使用IP地址，在容器重启后就可能会因为IP地址的变化导致从机无法连接到主机。使用<code>--link</code>参数创建网络别名就是为了在启动Redis服务器时在<code>redis-server</code>后面的<code>--replicaof</code>参数后使用这个别名而不是IP地址。</p><p>接下来我们进入名为<code>redis-master</code>的容器，看看主从复制的配置是否成功。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker <span class=nb>exec</span> -it redis-master /bin/bash
</code></pre></td></tr></table></div></div></div><p>通过<code>redis-cli</code>启动命令行工具。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>redis-cli
127.0.0.1:6379&gt; info replication
<span class=c1># Replication</span>
role:master
connected_slaves:3
slave0:ip<span class=o>=</span>172.17.0.4,port<span class=o>=</span>6379,state<span class=o>=</span>online,offset<span class=o>=</span>1988,lag<span class=o>=</span><span class=m>0</span>
slave1:ip<span class=o>=</span>172.17.0.5,port<span class=o>=</span>6379,state<span class=o>=</span>online,offset<span class=o>=</span>1988,lag<span class=o>=</span><span class=m>1</span>
slave2:ip<span class=o>=</span>172.17.0.6,port<span class=o>=</span>6379,state<span class=o>=</span>online,offset<span class=o>=</span>1988,lag<span class=o>=</span><span class=m>1</span>
master_replid:94703cfa03c3ddc7decc74ca5b8dd13cb8b113ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1988
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1988
</code></pre></td></tr></table></div></div></div><h4 id=运行gitlab><a href=#运行gitlab class=anchor-link>#</a>运行GitLab</h4><p>GitLab是由GitLab Inc.开发的Git仓库管理工具，具有wiki、问题跟踪、持续集成等一系列的功能，分为社区版和企业版。通过Docker提供的虚拟化容器，我们可以安装社区版的Docker。因为GitLab需要使用SSH协议进行安全连接，我们要暴露容器的22端口，所以可以先将宿主机SSH连接的22端口修改为其他端口（如：12345），然后再进行后续的操作。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>vim /etc/ssh/sshd_config
</code></pre></td></tr></table></div></div></div><p>将其中定义端口的那行代码去掉注释并将端口修改为12345。</p><pre tabindex=0><code>Port 12345
</code></pre><p>重新启动<code>sshd</code>服务。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>systemctl restart sshd
</code></pre></td></tr></table></div></div></div><blockquote><p><strong>提示</strong>：修改端口后应该确保防火墙上也开启对应的端口，否则无法使用SSH连接到Linux服务器。</p></blockquote><p>创建需要用于数据卷映射操作的文件夹。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>mkdir -p /root/gitlab/<span class=o>{</span>config,logs,data<span class=o>}</span>
</code></pre></td></tr></table></div></div></div><p>基于<code>gitlab/gitlab-ce</code>镜像创建容器，并暴露80端口（HTTP连接）和22端口（SSH连接）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run -d -p 80:80 -p 22:22 --name gitlab -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce
</code></pre></td></tr></table></div></div></div><blockquote><p>说明：GitLab的启动比较缓慢，创建好容器后可能需要等待一段时间才能通过浏览器来进行访问。</p></blockquote><p>首次进入GitLab访问界面会提示我们修改管理员密码，设置好管理员密码后就可以在登录界面输入用户名<code>root</code>和刚才设置的密码登录到管理员控制台，在使用上还是非常简单和人性化的。</p><h3 id=构建镜像><a href=#构建镜像 class=anchor-link>#</a>构建镜像</h3><p>通过上面的讲解，我们已经掌握了如何通过官方提供的镜像来创建容器。当然如果愿意，我们也可以用配置好的容器来生成镜像。简而言之，<strong>Docker镜像是由文件系统叠加而成的，系统的最底层是bootfs，相当于就是Linux内核的引导文件系统；接下来第二层是rootfs，这一层可以是一种或多种操作系统（如Debian或Ubuntu文件系统），Docker中的rootfs是只读状态的；Docker利用联合挂载技术将各层文件系统叠加到一起，最终的文件系统会包含有底层的文件和目录，这样的文件系统就是一个镜像</strong>。</p><p>之前我们讲过了如何查找、列出镜像和拉取（下载）镜像，接下来看看构建镜像的两种方式：</p><ol><li>使用<code>docker commit</code>命令。（不推荐）</li><li>使用<code>docker build</code>命令和Dockerfile文件。</li></ol><h4 id=使用commit命令构建镜像><a href=#使用commit命令构建镜像 class=anchor-link>#</a>使用commit命令构建镜像</h4><p>为了演示如何构建镜像，我们先使用Ubuntu镜像来定制一个容器，命令如下所示。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run --name myubuntu -it ubuntu /bin/bash
</code></pre></td></tr></table></div></div></div><p>在容器中执行下面的命令来安装Apache服务器并退出容器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>apt -y upgrade
apt -y install apache2
<span class=nb>exit</span>
</code></pre></td></tr></table></div></div></div><p>我们将这个容器作为一个定制的Web服务器保存起来，当需要这样一台Web服务器的时候，就没有必要重新创建容器并安装Apache了。</p><p>首先我们通过下面的命令查看容器的ID。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker container ls -a
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>docker container ls -a
CONTAINER ID    IMAGE    COMMAND        CREATED        STATUS        PORTS    NAMES
014bdb321612    ubuntu   &quot;/bin/bash&quot;    5 minutes ago  Exited (0)             myubuntu
</code></pre><p>提交定制的容器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker commit 014bdb321612 jackfrued/mywebserver
</code></pre></td></tr></table></div></div></div><p>查看镜像文件。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker images
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>REPOSITORY              TAG       IMAGE ID        CREATED             SIZE
jackfrued/mywebserver   latest    795b294d265a    14 seconds ago      189 MB
</code></pre><p>生成镜像文件以后，后面就可以利用刚才创建的镜像文件来创建新的容器。</p><h4 id=使用dockerfile构建镜像><a href=#使用dockerfile构建镜像 class=anchor-link>#</a>使用Dockerfile构建镜像</h4><p>Dockerfile使用DSL（Domain Specific Language）来构建一个Docker镜像，只要编辑好了Dockerfile文件，就可以使用<code>docker build</code>命令来构建一个新的镜像。</p><p>我们先创建一个名为myapp的文件夹来保存项目代码和Dockerfile的文件，如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell><span class=o>[</span>ECS-root temp<span class=o>]</span><span class=c1># tree myapp</span>
myapp
├── api
│   ├── app.py
│   ├── requirements.txt
│   └── start.sh
└── Dockerfile
</code></pre></td></tr></table></div></div></div><p>其中api是Flask项目的文件夹，其中包括了项目代码、依赖项以及启动脚本等文件，具体内容如下所示：</p><p><code>app.py</code>文件：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=kn>from</span> <span class=nn>flask</span> <span class=kn>import</span> <span class=n>Flask</span>
<span class=kn>from</span> <span class=nn>flask_restful</span> <span class=kn>import</span> <span class=n>Resource</span><span class=p>,</span> <span class=n>Api</span>
<span class=kn>from</span> <span class=nn>flask_cors</span> <span class=kn>import</span> <span class=n>CORS</span>

<span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
<span class=n>CORS</span><span class=p>(</span><span class=n>app</span><span class=p>,</span> <span class=n>resources</span><span class=o>=</span><span class=p>{</span><span class=sa>r</span><span class=s1>&#39;/api/*&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;origins&#39;</span><span class=p>:</span> <span class=s1>&#39;*&#39;</span><span class=p>}})</span>
<span class=n>api</span> <span class=o>=</span> <span class=n>Api</span><span class=p>(</span><span class=n>app</span><span class=p>)</span>


<span class=k>class</span> <span class=nc>Product</span><span class=p>(</span><span class=n>Resource</span><span class=p>):</span>

    <span class=k>def</span> <span class=nf>get</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>products</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;Ice Cream&#39;</span><span class=p>,</span> <span class=s1>&#39;Chocolate&#39;</span><span class=p>,</span> <span class=s1>&#39;Coca Cola&#39;</span><span class=p>,</span> <span class=s1>&#39;Hamburger&#39;</span><span class=p>]</span>
        <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;products&#39;</span><span class=p>:</span> <span class=n>products</span><span class=p>}</span>


<span class=n>api</span><span class=o>.</span><span class=n>add_resource</span><span class=p>(</span><span class=n>Product</span><span class=p>,</span> <span class=s1>&#39;/api/products&#39;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></div><p><code>requirements.txt</code>文件：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-INI data-lang=INI><span class=na>flask</span>
<span class=na>flask-restful</span>
<span class=na>flask-cors</span>
<span class=na>gunicorn</span>
</code></pre></td></tr></table></div></div></div><p><code>start.sh</code>文件：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell><span class=cp>#!/bin/bash
</span><span class=cp></span><span class=nb>exec</span> gunicorn -w <span class=m>4</span> -b 0.0.0.0:8000 app:app
</code></pre></td></tr></table></div></div></div><blockquote><p><strong>提示</strong>：需要给start.sh文件以执行权限，可以使用<code>chmod 755 start.sh</code>命令来做到。</p></blockquote><p>Dockerfile文件：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=c># 指定基础镜像</span><span class=err>
</span><span class=err></span><span class=k>FROM</span><span class=s> python:3.7</span><span class=err>
</span><span class=err></span><span class=c># 指定镜像的维护者</span><span class=err>
</span><span class=err></span><span class=k>MAINTAINER</span><span class=s> jackfrued &#34;jackfrued@126.com&#34;</span><span class=err>
</span><span class=err></span><span class=c># 将指定文件添加到容器中指定的位置</span><span class=err>
</span><span class=err></span><span class=k>ADD</span> api/* /root/api/<span class=err>
</span><span class=err></span><span class=c># 设置工作目录</span><span class=err>
</span><span class=err></span><span class=k>WORKDIR</span><span class=s> /root/api</span><span class=err>
</span><span class=err></span><span class=c># 执行命令(安装Flask项目的依赖项)</span><span class=err>
</span><span class=err></span><span class=k>RUN</span> pip install -r requirements.txt -i https://pypi.doubanio.com/simple/<span class=err>
</span><span class=err></span><span class=c># 容器启动时要执行的命令</span><span class=err>
</span><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;./start.sh&#34;</span><span class=p>]</span><span class=err>
</span><span class=err></span><span class=c># 暴露端口</span><span class=err>
</span><span class=err></span><span class=k>EXPOSE</span><span class=s> 8000</span><span class=err>
</span></code></pre></td></tr></table></div></div></div><p>我们来解释一下上面的Dockerfile文件。Dockerfile文件通过特殊的指令来指定基础镜像（FROM指令）、创建容器后需要指定的命令（RUN指令）以及需要暴露的端口（EXPOSE）等信息。我们稍后会专门为大家介绍这些Dockfile中的指令。</p><p>接下来我们可以使用<code>docker build</code>命令来创建镜像，如下所示。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker build -t <span class=s2>&#34;jackfrued/myapp&#34;</span> .
</code></pre></td></tr></table></div></div></div><blockquote><p>提示：上面的命令最后面的<code>.</code> 千万不要漏掉了哦，它表示从当前路径下寻找Dockerfile。</p></blockquote><p>通过下面的命令可以查看创建好的镜像。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker images
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
jackfrued/myapp              latest              6d6f026a7896        5 seconds ago       930 MB
</code></pre><p>如果想知道镜像文件是如何创建出来的，可以使用下面的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker <span class=nb>history</span> jackfrued/myapp
</code></pre></td></tr></table></div></div></div><pre tabindex=0><code>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
6d6f026a7896        31 seconds ago      /bin/sh -c #(nop)  EXPOSE 8000/tcp              0 B                 
3f7739173a79        31 seconds ago      /bin/sh -c #(nop)  ENTRYPOINT [&quot;./start.sh&quot;]    0 B                 
321e6bf09bf1        32 seconds ago      /bin/sh -c pip install -r requirements.txt...   13 MB               
2f9bf2c89ac7        37 seconds ago      /bin/sh -c #(nop) WORKDIR /root/api             0 B                 
86119afbe1f8        37 seconds ago      /bin/sh -c #(nop) ADD multi:4b76f9c9dfaee8...   870 B               
08d465e90d4d        3 hours ago         /bin/sh -c #(nop)  MAINTAINER jackfrued &quot;j...   0 B                 
fbf9f709ca9f        12 days ago         /bin/sh -c #(nop)  CMD [&quot;python3&quot;]              0 B 
</code></pre><p>使用该镜像来创建容器运行Web服务器。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run -d -p 8000:8000 --name myapp jackfrued/myapp
</code></pre></td></tr></table></div></div></div><p>如果希望将上面创建的镜像文件放到dockerhub仓库中，可以按照如下所示的步骤进行操作。</p><p>通过下面的命令登录到dockerhub。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker login
</code></pre></td></tr></table></div></div></div><p>输入用户名和口令进行登录。</p><pre tabindex=0><code>Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: jackfrued
Password: 
Login Succeeded
</code></pre><p>通过下面的命令将镜像推到仓库中。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker push jackfrued/webserver
</code></pre></td></tr></table></div></div></div><p><img src=/res/dockerhub-repo.png alt></p><h4 id=dockerfile指令><a href=#dockerfile指令 class=anchor-link>#</a>Dockerfile指令</h4><p>想了解Dockerfile的指令可以查看官方提供的<a href=https://docs.docker.com/engine/reference/builder/ target=_blank rel=noopener>参考手册</a>，下面我们为大家介绍一些常用的指令。</p><ol><li><p><strong>FROM</strong>：设置基础镜像，必须是Dockerfile中的第一条指令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>FROM</span><span class=s> &lt;镜像名&gt; [AS &lt;别名&gt;]</span><span class=err>
</span></code></pre></td></tr></table></div></div></div><p>或</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>FROM</span><span class=s> &lt;镜像名&gt;[:&lt;标签&gt;] [AS &lt;别名&gt;]</span><span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>RUN</strong>：指定构建镜像时要执行的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>RUN</span> &lt;命令&gt; <span class=o>[</span>参数1<span class=o>]</span>, <span class=o>[</span>参数2<span class=o>]</span>, ... <span class=err>
</span></code></pre></td></tr></table></div></div></div><p>或</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>RUN</span> <span class=o>[</span><span class=s2>&#34;可执行文件&#34;</span>, <span class=s2>&#34;参数1&#34;</span>, <span class=s2>&#34;参数2&#34;</span>, ...<span class=o>]</span><span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>CMD</strong>：指定构建镜像后要执行的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>CMD</span> &lt;命令&gt; <span class=o>[</span>参数1<span class=o>]</span>, <span class=o>[</span>参数2<span class=o>]</span>, ...<span class=err>
</span></code></pre></td></tr></table></div></div></div><p>或</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;可执行文件&#34;</span><span class=p>,</span> <span class=s2>&#34;参数1&#34;</span><span class=p>,</span> <span class=s2>&#34;参数2&#34;</span><span class=p>,</span> <span class=err>...</span><span class=p>]</span><span class=err>
</span></code></pre></td></tr></table></div></div></div><blockquote><p>说明：Docker不同于虚拟机，容器本身就是一个进程，容器中的应用应该位于前台运行。CMD命令相当于就是用来指定容器主进程（创建容器后要在前台执行的程序）的，如果主进程结束了，容器也就停止运行了。所以在容器中启动Nginx不能使用<code>service nginx start</code>或是<code>systemctl start nginx</code>而是要通过<code>CMD ["nginx", "-g", "daemon off;"]</code>让它在前台运行。</p></blockquote></li><li><p><strong>ENTRYPOINT</strong>：和CMD类似，也可以执行命令，但<code>docker run</code>命令行中指定的任何参数都会被当做参数再次传给ENTRYPOINT指令中的命令，这就使得我们可以构建一个镜像，它既可以运行一个默认的命令，也支持通过<code>docker run</code>命令行为该命令指定可覆盖的参数选项。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>ENTRYPOINT</span> &lt;命令&gt; <span class=o>[</span>参数1<span class=o>]</span>, <span class=o>[</span>参数2<span class=o>]</span>, ...<span class=err>
</span></code></pre></td></tr></table></div></div></div><p>或</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;可执行文件&#34;</span><span class=p>,</span> <span class=s2>&#34;参数1&#34;</span><span class=p>,</span> <span class=s2>&#34;参数2&#34;</span><span class=p>,</span> <span class=err>...</span><span class=p>]</span><span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>WORKDIR</strong>：在通过镜像创建新容器时，在容器内部创建一个工作目录，ENTRYPOINT和CMD指定的程序会在这个目录下执行。在使用<code>docker run</code>命令时可以通过<code>-w</code>参数来覆盖由WORKDIR指定的工作目录。例如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>WORKDIR</span><span class=s> /opt/webapp</span><span class=err>
</span></code></pre></td></tr></table></div></div></div><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run -w /usr/share/webapp ...
</code></pre></td></tr></table></div></div></div></li><li><p><strong>ENV</strong>：在创建镜像时设置环境变量。在使用<code>docker run</code>命令时，可以通过<code>-e</code>参数来修改环境变量的设置。例如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>ENV</span> <span class=nv>DEFAULT_PORT</span><span class=o>=</span><span class=m>8080</span>
</code></pre></td></tr></table></div></div></div><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker run -e <span class=s2>&#34;DEFAULT_PORT=8000&#34;</span> ...
</code></pre></td></tr></table></div></div></div></li><li><p><strong>USER</strong>：指定镜像会以什么用户身份去运行。例如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>USER</span><span class=s> nginx</span><span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>VOLUME</strong>：在创建容器时添加一个数据卷的挂载点。通过数据卷操作可以实现容器间数据的共享和重用，对卷所作的修改可以马上生效而不需要重新启动容器，我们之前创建容器时使用<code>--volume</code>参数就是为了实现数据卷的映射操作。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>VOLUME</span> <span class=p>[</span><span class=s2>&#34;/路径1&#34;</span><span class=p>,</span> <span class=s2>&#34;/路径2/子路径2.1/&#34;</span><span class=p>,</span> <span class=err>...</span><span class=p>]</span><span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>ADD</strong>：将构建目录下的文件和文件夹复制到镜像中，如果是压缩文件和归档文件，ADD命令会对这些文件进行解压缩解归档的操作。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>ADD</span> <span class=o>[</span>--chown<span class=o>=</span>&lt;用户&gt;:&lt;用户组&gt;<span class=o>]</span> &lt;源文件&gt; &lt;目标文件&gt;<span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>COPY</strong>：非常类似于ADD，但不会主动对文件进行提取操作。</p></li><li><p><strong>LABEL</strong>：为Docker镜像添加一些元数据，在使用<code>docker inspect</code>命令时会看到这些元数据。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>LABEL</span> <span class=nv>version</span><span class=o>=</span><span class=s2>&#34;1.0.0&#34;</span> <span class=nv>location</span><span class=o>=</span><span class=s2>&#34;Chengdu&#34;</span><span class=err>
</span></code></pre></td></tr></table></div></div></div></li><li><p><strong>ONBUILD</strong>：为镜像添加触发器，当一个镜像被用作其他镜像的基础镜像，触发器将会被执行。例如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=k>ONBUILD</span> <span class=k>ADD</span> . /app/src<span class=err>
</span><span class=err></span><span class=k>ONBUILD</span> <span class=k>RUN</span> <span class=nb>cd</span> /app/src <span class=o>&amp;&amp;</span> make<span class=err>
</span></code></pre></td></tr></table></div></div></div></li></ol><h3 id=多容器管理><a href=#多容器管理 class=anchor-link>#</a>多容器管理</h3><p>我们的项目可能会使用了多个容器，容器多了之后管理容器的工作就会变得麻烦。如果要对多个容器进行自动配置使得容器可以相互协作甚至实现复杂的调度，这就需要进行容器编排。Docker原生对容器编排的支持非常弱，但是可以通过社区提供的工具来实现容器编排。</p><h4 id=docker-compose><a href=#docker-compose class=anchor-link>#</a>Docker Compose</h4><p>可以通过安装Docker Compose工具来实现基于YAML文件的容器编排，YAML文件会定义一系列的容器以及容器运行时的属性，Docker Compose会根据这些配置来管理容器。</p><ol><li><p>安装Docker Compose。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>curl -L <span class=s2>&#34;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-</span><span class=k>$(</span>uname -s<span class=k>)</span><span class=s2>-</span><span class=k>$(</span>uname -m<span class=k>)</span><span class=s2>&#34;</span> -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre></td></tr></table></div></div></div><blockquote><p>说明：如果没有curl工具，在CentOS下可以先通过包管理工具yum安装curl再执行上面的命令。</p></blockquote><p>当然我们也可以使用Python的包管理工具pip来安装Docker Compose，命令如下所示。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>pip3 install -U docker-compose
</code></pre></td></tr></table></div></div></div></li><li><p>使用Docker Compose。</p><p>我们在刚才的Flask项目中引入缓存，然后再利用Flask提供的数据接口为前端页面提供数据，使用Vue.js进行页面渲染并将静态页面部署在Nginx服务器上。项目文件夹结构如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell><span class=o>[</span>ECS-root ~<span class=o>]</span><span class=c1># tree temp</span>
temp
├── docker-compose.yml
├── html
│   └── index.html
└── myapp
    ├── api
    │   ├── app.py
    │   ├── requirements.txt
    │   └── start.sh
    └── Dockerfile
</code></pre></td></tr></table></div></div></div><p>修改后的app.py文件代码如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=kn>from</span> <span class=nn>pickle</span> <span class=kn>import</span> <span class=n>dumps</span><span class=p>,</span> <span class=n>loads</span>

<span class=kn>from</span> <span class=nn>flask</span> <span class=kn>import</span> <span class=n>Flask</span>
<span class=kn>from</span> <span class=nn>flask_restful</span> <span class=kn>import</span> <span class=n>Resource</span><span class=p>,</span> <span class=n>Api</span>
<span class=kn>from</span> <span class=nn>flask_cors</span> <span class=kn>import</span> <span class=n>CORS</span>
<span class=kn>from</span> <span class=nn>redis</span> <span class=kn>import</span> <span class=n>Redis</span>

<span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
<span class=n>CORS</span><span class=p>(</span><span class=n>app</span><span class=p>,</span> <span class=n>resources</span><span class=o>=</span><span class=p>{</span><span class=sa>r</span><span class=s1>&#39;/api/*&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;origins&#39;</span><span class=p>:</span> <span class=s1>&#39;*&#39;</span><span class=p>}})</span>
<span class=n>api</span> <span class=o>=</span> <span class=n>Api</span><span class=p>(</span><span class=n>app</span><span class=p>)</span>
<span class=n>redis</span> <span class=o>=</span> <span class=n>Redis</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;redis-master&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>6379</span><span class=p>)</span>


<span class=k>class</span> <span class=nc>Product</span><span class=p>(</span><span class=n>Resource</span><span class=p>):</span>

    <span class=k>def</span> <span class=nf>get</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>data</span> <span class=o>=</span> <span class=n>redis</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;products&#39;</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>data</span><span class=p>:</span>
            <span class=n>products</span> <span class=o>=</span> <span class=n>loads</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>products</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;Ice Cream&#39;</span><span class=p>,</span> <span class=s1>&#39;Chocolate&#39;</span><span class=p>,</span> <span class=s1>&#39;Coca Cola&#39;</span><span class=p>,</span> <span class=s1>&#39;Hamburger&#39;</span><span class=p>]</span>
            <span class=n>redis</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;products&#39;</span><span class=p>,</span> <span class=n>dumps</span><span class=p>(</span><span class=n>products</span><span class=p>))</span>
        <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;products&#39;</span><span class=p>:</span> <span class=n>products</span><span class=p>}</span>


<span class=n>api</span><span class=o>.</span><span class=n>add_resource</span><span class=p>(</span><span class=n>Product</span><span class=p>,</span> <span class=s1>&#39;/api/products&#39;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></div><p>html文件夹用来保存静态页面，稍后我们会通一个运行Nginx的容器来向浏览器提供静态页面。index.html文件的内容如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HTML data-lang=HTML><span class=cp>&lt;!DOCTYPE html&gt;</span>
<span class=p>&lt;</span><span class=nt>html</span> <span class=na>lang</span><span class=o>=</span><span class=s>&#34;en&#34;</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;utf-8&#34;</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>首页<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;app&#34;</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>h2</span><span class=p>&gt;</span>产品列表<span class=p>&lt;/</span><span class=nt>h2</span><span class=p>&gt;</span>
        <span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
            <span class=p>&lt;</span><span class=nt>li</span> <span class=na>v-for</span><span class=o>=</span><span class=s>&#34;product in products&#34;</span><span class=p>&gt;</span>{{ product }}<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
        <span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>script</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
    <span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
        <span class=k>new</span> <span class=nx>Vue</span><span class=p>({</span>
            <span class=nx>el</span><span class=o>:</span> <span class=s1>&#39;#app&#39;</span><span class=p>,</span> 
            <span class=nx>data</span><span class=o>:</span> <span class=p>{</span>
                <span class=nx>products</span><span class=o>:</span> <span class=p>[]</span>
            <span class=p>},</span>
            <span class=nx>created</span><span class=p>()</span> <span class=p>{</span>
                <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;http://1.2.3.4:8000/api/products&#39;</span><span class=p>)</span>
                    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>resp</span> <span class=p>=&gt;</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>json</span><span class=p>())</span>
                    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>json</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>products</span> <span class=o>=</span> <span class=nx>json</span><span class=p>.</span><span class=nx>products</span><span class=p>})</span>
            <span class=p>}</span>
        <span class=p>})</span>
    <span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</code></pre></td></tr></table></div></div></div><p>接下来，我们要通过docker-compose.yml文件来创建三个容器并指明容器之间的依赖关系。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-YAML data-lang=YAML><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3&#39;</span><span class=w>
</span><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>api-server</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w> </span><span class=l>./myapp</span><span class=w>
</span><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=s1>&#39;8000:8000&#39;</span><span class=w>
</span><span class=w>    </span><span class=nt>links</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=l>redis-master</span><span class=w>
</span><span class=w>  </span><span class=nt>web-server</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=s1>&#39;80:80&#39;</span><span class=w>
</span><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=l>./html:/usr/share/nginx/html</span><span class=w>
</span><span class=w>  </span><span class=nt>redis-master</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span><span class=w>    </span><span class=nt>expose</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=s1>&#39;6379&#39;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>有了这个YAML文件，我们就可以使用<code>docker-compose</code>命令来创建容器运行项目，其命令如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell><span class=o>[</span>ECS-root temp<span class=o>]</span><span class=c1># docker-compose up</span>
Creating network <span class=s2>&#34;temp_default&#34;</span> with the default driver
Creating temp_web-server_1   ... <span class=k>done</span>
Creating temp_redis-master_1 ... <span class=k>done</span>
Creating temp_api-server_1   ... <span class=k>done</span>
Attaching to temp_redis-master_1, temp_web-server_1, temp_api-server_1
redis-master_1  <span class=p>|</span> 1:C <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.828 <span class=c1># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span>
redis-master_1  <span class=p>|</span> 1:C <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.828 <span class=c1># Redis version=5.0.6, bits=64, commit=00000000, modified=0, pid=1, just started</span>
redis-master_1  <span class=p>|</span> 1:C <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.828 <span class=c1># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span>
redis-master_1  <span class=p>|</span> 1:M <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.830 * Running <span class=nv>mode</span><span class=o>=</span>standalone, <span class=nv>port</span><span class=o>=</span>6379.
redis-master_1  <span class=p>|</span> 1:M <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.831 <span class=c1># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span>
redis-master_1  <span class=p>|</span> 1:M <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.831 <span class=c1># Server initialized</span>
redis-master_1  <span class=p>|</span> 1:M <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.831 <span class=c1># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory = 1&#39; to /etc/sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory=1&#39; for this to take effect.</span>
redis-master_1  <span class=p>|</span> 1:M <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.831 <span class=c1># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#39; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span>
redis-master_1  <span class=p>|</span> 1:M <span class=m>05</span> Dec <span class=m>2019</span> 11:57:26.831 * Ready to accept connections
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>1<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Starting gunicorn 20.0.4
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>1<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Listening at: http://0.0.0.0:8000 <span class=o>(</span>1<span class=o>)</span>
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>1<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Using worker: sync
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>8<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Booting worker with pid: <span class=m>8</span>
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>9<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Booting worker with pid: <span class=m>9</span>
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>10<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Booting worker with pid: <span class=m>10</span>
api-server_1    <span class=p>|</span> <span class=o>[</span>2019-12-05 11:57:27 +0000<span class=o>]</span> <span class=o>[</span>11<span class=o>]</span> <span class=o>[</span>INFO<span class=o>]</span> Booting worker with pid: <span class=m>11</span>
</code></pre></td></tr></table></div></div></div><p>要停止容器的运行，可以使用下面的命令。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell>docker-compose down
</code></pre></td></tr></table></div></div></div></li></ol><h4 id=kubernetesk8s><a href=#kubernetesk8s class=anchor-link>#</a>Kubernetes（K8S）</h4><p>实际的生产环境中常常需要部署和管理多个协同工作的容器，docker compose解决了多容器创建和管理的问题，但是实际项目中，我们还需要Kubernetes（以下都简称为K8S）来提供一个跨主机集群的容器调度平台。K8S可以进行自动化容器的部署、扩展和操作，从而提供以容器为中心的基础架构。该项目是谷歌在2014年启动的项目，建立在谷歌公司十余年运维经验的基础之上，而且谷歌自己的应用也是运行在容器上的。</p></div><ul class=post-copyright><li class="copyright-item author"><span class=copyright-item-text>作者</span>：<span class="p-author h-card">骆昊</span></li><li class="copyright-item link"><span class=copyright-item-text>链接</span>：<a href=https://github.com/jackfrued/Python-100-Days target=_blank rel=noopener>https://github.com/jackfrued/Python-100-Days</a></li><li class="copyright-item license"><span class=copyright-item-text>许可</span>：本文采用<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>「CC BY-NC-SA 4.0」</a>协议，转载请注明出处。</li></ul></article><div class=related-posts><h2 class=related-title>相关文章：<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon related-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6.0-12-5.4-12-12v-92h-92c-6.6.0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6.0 12 5.4 12 12v92h92c6.6.0 12 5.4 12 12v56z"/></svg></h2><ul class=related-list><li class=related-item><a href=/python/01.%E5%88%9D%E8%AF%86python/ class=related-link>01.初识Python</a></li><li class=related-item><a href=/python/02.%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/ class=related-link>02.语言元素</a></li><li class=related-item><a href=/python/03.%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/ class=related-link>03.分支结构</a></li><li class=related-item><a href=/python/04.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/ class=related-link>04.循环结构</a></li><li class=related-item><a href=/python/05.%E6%9E%84%E9%80%A0%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91/ class=related-link>05.构造程序逻辑</a></li></ul></div><div class=post-tags><a href=/tags/python/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>python</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2021–2022&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;hanxin</div><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script>
<text class=poem_sentence></text>
<text class=poem_info></text>
<script type=text/javascript>jinrishici.load(function(a){var b=document.querySelector(".poem_sentence"),c=document.querySelector(".poem_info");b.innerHTML=a.data.content,c.innerHTML='——'+a.data.origin.author})</script></div></footer></div><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script>
<script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>